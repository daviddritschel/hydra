module spectral

!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
! This module contains all subroutines related to spectral inversion
! and differentiation.
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

 !Import constants and parameters:
use constants
 !Import FFT module:
use sta2dfft

 !Declarations:
implicit none

 !Maximum x wavenumber (nwx) and values +/-1:
integer,parameter:: nwx=nx/2,nwxm1=nwx-1,nwxp1=nwx+1

 !Common arrays, constants:
double precision:: green(0:nxm1,0:ny,nz),rksq(0:nxm1,0:ny)
double precision:: decy(nym1,nxm1,nz)
double precision:: diss(0:nxm1,0:ny),filt(0:nxm1,0:ny)
double precision:: bflo(0:nxm1,0:ny),bfhi(0:nxm1,0:ny)
double precision:: danorm(0:ny,0:nxm1)
double precision:: bety(0:ny,0:nxm1),qb(0:ny,0:nxm1)
double precision:: sfwind(0:nxm1,0:ny),yg(0:ny)
double precision:: srwfm

 !Vertical structure:
double precision:: hhat(nz),kdsq(nz),kkb(nz),kk0(nz),kkm(nz)
double precision:: vl2m(nz,nz),vm2l(nz,nz)
double precision:: umha(nz)

 !Wavenumbers etc needed for FFTs, derivatives, etc:
double precision:: rkx(0:nxm1),hrkx(nx),rky(0:ny)
double precision:: xtrig(2*nx),ytrig(2*ny)
integer:: xfactors(5),yfactors(5)

!==========================================================================!
! From main code: call init_spectral                to initialise          !
! then            call main_invert(qq,pp,uu,vv)     to perform inversion   !
!==========================================================================!

!::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 !Internal subroutine definitions (inherit global variables):
!::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

contains

!=======================================================================

subroutine init_spectral

 !Declarations:
implicit none

 !Local variables:
double precision:: wkp(0:ny,0:nxm1),sky(ny)
double precision:: dafx(0:nxm1),dafy(0:ny)
double precision:: uuha(1:nz)
double precision:: rkxmax,rkymax
double precision:: td,fac,div,argm,argp
double precision:: rkmsi
integer:: ix,iy,iz,kx,ky,m,k

!--------------------------------------------------------------------
 !Set up 2D FFTs and other commonly-used spectral arrays:
call init2dfft(nx,ny,ellx,elly,xfactors,yfactors,xtrig,ytrig,hrkx,sky)

 !Define x wavenumbers (for cosines then sines in reverse):
rkx(0)=zero
do kx=1,nwxm1
  rkx(kx   )=hrkx(2*kx)
  rkx(nx-kx)=hrkx(2*kx)
enddo
rkx(nwx)=hrkx(nx)
rkxmax=pi*dble(nx)/ellx

 !Define y wavenumbers (including 0 wavenumber - not in sky above):
fac=pi/elly
rkymax=fac*dble(ny)
do ky=0,ny
   rky(ky)=fac*dble(ky)
enddo

 !Define de-aliasing filter (2/3 rule):
dafx(0)=one
do kx=1,nxm1
   if (rkx(kx) < f23*rkxmax) then
      dafx(kx)=one
   else
      dafx(kx)=zero
   endif
enddo

dafy(0)=one
do ky=1,ny
   if (rky(ky) < f23*rkymax) then
      dafy(ky)=one
   else
      dafy(ky)=zero
   endif
enddo

do ky=0,ny
   do kx=0,nxm1
      filt(kx,ky)=dafx(kx)*dafy(ky)
   enddo
enddo

 !Define squared horizontal wavenumber:
do ky=0,ny
   do kx=0,nxm1
      rksq(kx,ky)=rkx(kx)**2+rky(ky)**2
   enddo
enddo

 !Define Butterworth low-pass (F) & high-pass (1-F) filters:
fac=18.d0/(rkxmax**2+rkymax**2)
bflo=filt/(one+(fac*rksq)**2)
bfhi=filt*(one-bflo)

 !Define horizontal hyperdiffusion spectral operator:
rkmsi=one/max(rkxmax**2,rkymax**2)
diss=cdamp*(rkmsi*rksq)**nnu

!--------------------------------------------------------------------
 !Read vertical structure and mode files (generated by vertical.f90):
open(60,file='vertical.asc',status='old')
do iz=1,nz
   read(60,*) hhat(iz),kkb(iz)
enddo
close(60)
 !hhat = mean layer depth / total mean depth (sum(hhat) = 1).
 !kkb  = f^2/(b'*H) where f = Coriolis frequency, b' = buoyancy
 !       difference between layer iz and iz+1, H = total mean depth.
 !Note: kkb(nz) is unused.

 !Ensure hhat sums to 1 - this is essential:
fac=1.d0/sum(hhat)
hhat=fac*hhat

!-----------------------------------------------------------------
 !For computing relative vorticity and implementing Ekman drag:
do iz=1,nz-1
   kk0(iz)=kkb(iz)/hhat(iz)
   kkm(iz+1)=kkb(iz)/hhat(iz+1)
enddo

!-----------------------------------------------------------------
 !Read vertical eigenvalues and eigenmodes:
open(60,file='modes.asc',status='old')
do m=1,nz
   read(60,*) kdsq(m)
enddo
 !Note, kdsq(m) corresponds to lambda_m in the notes.
do m=1,nz
   do iz=1,nz
      read(60,*) vl2m(iz,m),vm2l(iz,m)
   enddo
enddo
close(60)
 !vl2m converts layer quantities to  mode quantities
 !vm2l converts  mode quantities to layer quantities

!--------------------------------------------------------------------
 !Read layer-mean zonal flow and project onto vertical modes:
open(60,file='meanflow.asc',status='old')
do iz=1,nz
   read(60,*) uuha(iz)
enddo
 !"ha" stands for "horizontal average" (i.e. over a layer).
close(60)
do m=1,nz
   umha(m)=sum(vl2m(:,m)*uuha)
enddo
 !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 ! To help read this code, a field "ff" in layer space is represented
 ! by "fm" in mode space, e.g. uuha for layers and umha for modes.
 ! Below we also use layer-mode pairs like (qq,qm) and (pp,pm).
 !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

!--------------------------------------------------------------------
 !Define Green function for inverting Lap(psi)-kdsq*psi = S for psi:
rksq(0,0)=one
green(:,:,1)=-one/rksq
rksq(0,0)=zero
green(0,0,1)=zero
 !The above is for vertical mode m = 1, for which kdsq(m) = 0.
 !The (0,0) wavevector is removed; green cannot be used for this.

 !Define Green function for m > 1, for which kdsq(m) > 0:
do m=2,nz
   green(:,:,m)=-one/(kdsq(m)+rksq)
enddo

!--------------------------------------------------------------------
 !Hyperbolic functions needed as solutions of Helmholtz's equation:
fac=one/dble(ny)
do iy=0,ny
   yg(iy)=fac*dble(iy)
enddo
 !yg = (y - y_min)/L_y here; it is redefined as y below
do m=1,nz
   do kx=1,nxm1
      fac=sqrt(kdsq(m)+rkx(kx)**2)*elly
      div=one/(one-exp(-two*fac))
      do iy=1,nym1
         argm=fac*(one-yg(iy))
         argp=fac*(one+yg(iy))
         decy(iy,kx,m)=(exp(-argm)-exp(-argp))*div
      enddo
   enddo
enddo
 !The above functions allow one to remove the sinusoidally-varying part
 !of the streamfunction along the upper and lower edges of the domain.
 !These are needed to permit the PV to vary arbitrarily there.

 !Define area weights needed to compute a horizontal average:
danorm( 0,:)=f12*dsumi
danorm(1:nym1,:)=dsumi
danorm(ny,:)=f12*dsumi
 !The average of a field f is computed using sum(f*danorm).

!------------------------------------------------------------------
 !If bathymetry eta_b is present, read in qb = f_0*eta_b/H_{nz}:
if (bath) then
   open(11,file='bath.r8',form='unformatted', &
        access='direct',status='old',recl=2*nhbytes)
   read(11,rec=1) td,qb
   close(11)
endif

!------------------------------------------------------------------
 !If wind-stress forcing is present, define spectral function to
 !add to PV tendency in the uppermost layer, i.e.
 !Dq_1/Dt = fwind*sin(2*pi*(y-y_min)/(y_max-y_min)):
if (wind) then
   do ix=0,nxm1
      wkp(:,ix)=fwind*sin(twopi*yg)
   enddo
   !yg = (y-y_min)/(y_max-y_min) is defined above in this routine.
   call ptospc_fc(nx,ny,wkp,sfwind,xfactors,yfactors,xtrig,ytrig)
   !sfwind is added to (spectral) Dq_1/Dt in evolution.f90.
   sfwind(0,0)=zero
   ! The mean tendency is here zero; for a more general wind-stress
   ! forcing function, it may be desirable to keep the this zero to
   ! avoid a build up of mean PV in the uppermost layer, which will
   ! induce a growth in barotropic circulation in the domain.
endif
 !Note: we have to transform a sine in y function to a cosine
 !      series above to be compatable with the representation
 !      of PV as a cosine series in y.

!------------------------------------------------------------------
 !Define y grid lines for use in computing zonal-average flow:
do iy=0,ny
   yg(iy)=ymin+gly*dble(iy)
enddo

 !Define beta*y for use in PV inversion --- see main_invert below:
do ix=0,nxm1
   bety(:,ix)=beta*yg
enddo
 !This is written as a 2D array for simpler use in the main code.

 !Define maximum Rossby wave frequency (for time stepping):
if (beta > 0) then
   srwfm=beta*max(rkx(1),rky(1))/(rkx(1)**2+rky(1)**2)
else
   srwfm=small
endif

return
end subroutine init_spectral

!=======================================================================

subroutine main_invert(qq,pp,uu,vv)
 !Given the PV qq in all layers, this routine computes the
 !streamfunction pp and velocity field (uu,vv) in all layers.

 !Declarations:
implicit none

 !Passed arrays:
double precision:: qq(0:ny,0:nxm1,nz)
double precision:: pp(0:ny,0:nxm1,nz),uu(0:ny,0:nxm1,nz),vv(0:ny,0:nxm1,nz)

 !Local quantities:
double precision:: qm(0:ny,0:nxm1,nz),pm(0:ny,0:nxm1)
double precision:: wks(0:nxm1,0:ny),cppy(nym1,0:nxm1)
double precision:: pbot(0:nxm1),ptop(0:nxm1)
double precision:: rpm(0:ny),rum(ny)
double precision:: pmza(0:ny,nz),umza(0:ny,nz)
double precision:: ppza(0:ny,nz),uuza(0:ny,nz)
double precision:: pmha(nz),ppha(nz)
double precision:: uavg,pavg
integer:: ix,iy,iz,kx,ky,m

!------------------------------------------------------------------
 !Take away bathymetry contribution to bottom layer PV (iz = nz):
if (bath) qq(:,:,nz)=qq(:,:,nz)-qb

 !Project layer PV (in qq) onto vertical modes (as qm):
qm=zero
do m=1,nz
   do iz=1,nz
      qm(:,:,m)=qm(:,:,m)+vl2m(iz,m)*qq(:,:,iz)
   enddo
enddo

 !Remove beta*y from the barotropic mode PV:
qm(:,:,1)=qm(:,:,1)-bety
 !Note, sum_{iz} vl2m(iz,1) = 1 (see init/vertical.f90)

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 !For each vertical mode m, find the associated streamfunction pm:
do m=1,nz

    !-------------------------------------------------------------
    !First deal with the zonal-average part (kx = 0):
   if (m == 1) then
       !For the barotropic mode, we must find the zonal average by
       !integration over y:
      do iy=0,ny
          !Use pmza to store the zonal-average PV (below dnxi = 1/nx):
         pmza(iy,1)=dnxi*sum(qm(iy,:,1))
      enddo
       !Remove the zonal average from qm(:,:,1) for inversion below:
      do ix=0,nxm1
         pm(:,ix)=qm(:,ix,1)-pmza(:,1)
      enddo
       !Integrate PV to get zonal-average zonal velocity:
      umza(0,1)=zero
      do iy=1,ny
         umza(iy,1)=umza(iy-1,1)-hgly*(pmza(iy-1,1)+pmza(iy,1))
      enddo
       !hgly = dy/2 (half the y grid spacing).
       !Remove mean over y (to enforce zero global momentum):
      uavg=dnyi*(sum(umza(1:nym1,1))+f12*umza(ny,1))
       !dnyi = 1/ny
      umza(:,1)=umza(:,1)-uavg

       !Integrate zonal velocity to get zonal-average streamfunction:
      pmza(0,1)=zero
      do iy=1,ny
         pmza(iy,1)=pmza(iy-1,1)-hgly*(umza(iy-1,1)+umza(iy,1))
      enddo
       !Remove mean (to enforce global mass conservation):
      pavg=dnyi*(sum(pmza(1:nym1,1))+f12*pmza(ny,1))
      pmza(:,1)=pmza(:,1)-pavg

       !Add prescribed mean barotropic zonal velocity to umza:
      umza(:,1)=umza(:,1)+umha(1)

   else
       !For all other vertical modes, store modal PV in 2D pm array
       !after adjusting zonal-mean part for the boundary conditions:
      do iy=0,ny
         pmza(iy,m)=-umha(m)*yg(iy)
         umza(iy,m)= umha(m)
      enddo
       !umha(m) stands for \check{U}_m^0 in the notes
      do ix=0,nxm1
         pm(:,ix)=qm(:,ix,m)+kdsq(m)*pmza(:,m)
      enddo
       !Note, there may still be a zonal-mean part in pm, but
       !it is not the linear part subtracted above to enforce
       !the zonal velocity boundary conditions --- see below.
   endif

    !-------------------------------------------------------------
    !Next find the remaining part of the solution:
 
    !FFT mode PV to wavenumber space (kx,ky) as wks temporarily:
   call ptospc_fc(nx,ny,pm,wks,xfactors,yfactors,xtrig,ytrig)
    !ptospc_fc allows the PV to vary generally along the boundaries.

    !Invert to get uncorrected streamfunction (varying in x on
    !the boundaries):
   wks=green(:,:,m)*wks
    !See init_spectral above for definition of green.
   
    !For m > 1, the zonal part for kx = 0 may be non-zero; add this
    !(\check\Psi_m^* in the notes) to pmza above after a FFT:
   if (m > 1) then
       !Extract zonal part (spectral in y; cosine coefficients):
      rpm=wks(0,:)
       !Compute associated zonal velocity (\check{U}_m^* in the notes):
      call yderiv_fc(1,ny,rky,rpm,rum)
      wks(0,:)=zero !removes kx = 0 component from streamfunction
      call dct(1,ny,rpm,ytrig,yfactors) !cosine transform
      pmza(:,m)=pmza(:,m)+rpm
      call dst(1,ny,rum,ytrig,yfactors) !sine transform
      umza(1:nym1,m)=umza(1:nym1,m)+rum(1:nym1)
       !rum = 0 on y boundaries, iy = 0 & ny. rum is a sine series in y.
   endif

    !At this point wks has no zonal component, i.e. wks(0,:) = 0.
    !We now deal with the non-zonal solution for streamfunction:
   
    !Inverse transform the non-zonal (uncorrected) streamfunction:
   call spctop_fc(nx,ny,wks,pm,xfactors,yfactors,xtrig,ytrig)

    !Do a full transform of pm at y = ymin and ymax and obtain the
    !interior field (cppy) that must be subtracted to give pm = 0
    !at y = ymin and ymax:
   pbot=pm( 0,:)
   ptop=pm(ny,:)
   call forfft(1,nx,pbot,xtrig,xfactors)
   call forfft(1,nx,ptop,xtrig,xfactors)

    !Define the (non-zonal, kx > 0) interior semi-spectral field:
   cppy(:,0)=zero
   do kx=1,nxm1
      do iy=1,nym1
         cppy(iy,kx)=pbot(kx)*decy(ny-iy,kx,m)+ptop(kx)*decy(iy,kx,m)
      enddo
   enddo
    !Invert using a full transform in x for all interior y grid lines:
   call revfft(nym1,nx,cppy,xtrig,xfactors)

    !Remove cppy to obtain the final (non-zonal) streamfunction "qm",
    !which, by construction, vanishes along the y edges of the domain:
   qm( 0,:,m)=zero
   qm(1:nym1,:,m)=pm(1:nym1,:)-cppy
   qm(ny,:,m)=zero
    !qm stores the non-zonal streamfunction for mode m for use below.

enddo
 !End of loop over vertical modes.
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 !Project modal streamfunction in qm onto vertical layers as pp,
 !and also project mean flows in pmza & umza to ppza & uuza:
pp=zero
ppza=zero
uuza=zero
do m=1,nz
   do iz=1,nz
      pp(:,:,iz)=pp(:,:,iz)+vm2l(iz,m)*qm(:,:,m)
      ppza(:,iz)=ppza(:,iz)+vm2l(iz,m)*pmza(:,m)
      uuza(:,iz)=uuza(:,iz)+vm2l(iz,m)*umza(:,m)
   enddo
enddo

!------------------------------------------------------------------
 !Compute the non-zonal velocity field (uu,vv) from pp:
call velocity(pp,uu,vv)

 !Add back the zonal-average parts in ppza and uuza above:
do iz=1,nz
   do ix=0,nxm1
      pp(:,ix,iz)=pp(:,ix,iz)+ppza(:,iz)
      uu(:,ix,iz)=uu(:,ix,iz)+uuza(:,iz)
   enddo
enddo

!------------------------------------------------------------------
 !Use domain average of the PV definition to find the mean
 !streamfunction values:

 !Compute layer-mean zeta - q (the layer mean zeta is equal to
 !the circulation / horizontal domain area) -> ppha temporarily:
do iz=1,nz
   ppha(iz)=-glx*sum(uu(ny,:,iz)-uu(0,:,iz))/domarea &
                -sum(qq(:,:,iz)*danorm)
enddo
 !Note, only uu on the y boundaries contributes to circulation
 !(computed in first line) as the domain is periodic in x.

 !Solve A Psi_avg = zeta_avg - q_avg after projection onto
 !vertical modes; since A is singular (the barotropic mode
 !has a zero Rossby deformation wavenumber), we can only do
 !this for modes m > 1. Without loss of generality, we take
 !the barotropic layer-mean streamfunction to be zero:
pmha(1)=zero
do m=2,nz
   pmha(m)=sum(vl2m(:,m)*ppha)/kdsq(m)
enddo

 !Project pmha back to layers as ppha:
ppha=zero
do m=2,nz
   ppha=ppha+vm2l(:,m)*pmha(m)
enddo

 !Restore correct mean streamfunction values:
do iz=1,nz
   ppha(iz)=ppha(iz)-sum(pp(:,:,iz)*danorm)
   pp(:,:,iz)=pp(:,:,iz)+ppha(iz)
enddo

 !Restore original PV in the bottom layer (iz = nz):
if (bath) qq(:,:,nz)=qq(:,:,nz)+qb

return
end subroutine main_invert

!=======================================================================

subroutine velocity(pp,uu,vv)
! Computes the velocity components uu & vv from the streamfunction
! pp via uu = -d(pp)/dy and vv = d(pp)/dx (done in spectral space).

! *** This is done only for the non-zonal part (kx > 0) ***
  
! pp, uu & vv are all in physical space and include the domain edges,
! though pp = 0 on those edges (and likewise vv = 0).

implicit none

 !Passed arrays:
double precision:: pp(0:ny,0:nxm1,nz),uu(0:ny,0:nxm1,nz),vv(0:ny,0:nxm1,nz)

 !Local quantities:
double precision:: pps(0:nxm1,ny)
double precision:: ppx(0:nxm1,ny),vvi(ny,0:nxm1)
double precision:: ppy(0:nxm1,0:ny),uui(0:ny,0:nxm1)
integer:: iz

!-------------------------------------------------------------------
 !Loop over layers:
do iz=1,nz
    !Copy non-zero interior values of pp into temporary 2D array vvi:
   vvi=pp(1:ny,:,iz)

    !Transform vvi to spectral space as pps (sine series in y):
   call ptospc_fs(nx,ny,vvi,pps,xfactors,yfactors,xtrig,ytrig)

    !Compute d(pp)/dx = ppx spectrally :
   call xderiv_fs(nx,ny,hrkx,pps,ppx)

    !Transform ppx back to physical space as vvi:
   call spctop_cs(nx,ny,ppx,vvi,xfactors,yfactors,xtrig,ytrig)

    !Copy vvi into vv and add on zero edge values at iy = 0 & ny:
   vv(1:nym1,:,iz)=vvi(1:nym1,:)
   vv( 0,:,iz)=zero
   vv(ny,:,iz)=zero

    !Compute d(pp)/dy = ppy spectrally:
   call yderiv_fs(nx,ny,rky(1:ny),pps,ppy)

    !Transform ppy back to physical space as uui (cosine series):
   call spctop_fc(nx,ny,ppy,uui,xfactors,yfactors,xtrig,ytrig)

    !Copy -uui into uu:
   uu(:,:,iz)=-uui
enddo

return
end subroutine velocity

!=======================================================================

subroutine vorticity(qq,pp,zz)

! This routine computes the relative vorticity, given the current total
! PV field qq and streamfunction pp, i.e. following a call to inversion.

implicit none

! Passed arrays:
double precision:: qq(0:ny,0:nxm1,nz),pp(0:ny,0:nxm1,nz),zz(0:ny,0:nxm1,nz)

! Local variable:
integer:: iz

!-------------------------------------------------------------
! Top layer (iz = 1):
zz(:,:,1)=qq(:,:,1)-bety+kk0(1)*(pp(:,:,1)-pp(:,:,2))
! bety = beta*y here

! Intermediate layers:
do iz=2,nz-1
   zz(:,:,iz)=qq(:,:,iz)-bety+kkm(iz)*(pp(:,:,iz)-pp(:,:,iz-1))+ &
                              kk0(iz)*(pp(:,:,iz)-pp(:,:,iz+1))
enddo

! Bottom layer (iz = nz):
zz(:,:,nz)=qq(:,:,nz)-bety+kkm(nz)*(pp(:,:,nz)-pp(:,:,nz-1))
! Remove PV due to bathymetry if present:
if (bath) zz(:,:,nz)=zz(:,:,nz)-qb

! Note, kkm(iz) = f^2/(H_iz b'_{iz-1}) for iz = 2 to nz
! while kk0(iz) = f^2/(H_iz b'_{iz}) for iz = 1 to nz-1
! --- see init_spectral above.

return
end subroutine vorticity

!=======================================================================

subroutine gradient(fs,fx,fy)
! Computes the gradient of a spectral field fs, represented as a cosine
! series in y, and returns the gradient in physical space as (fx,fy).

implicit none

 !Passed arrays:
double precision:: fs(0:nxm1,0:ny,nz)
double precision:: fx(0:ny,0:nxm1,nz),fy(0:ny,0:nxm1,nz)

 !Local quantities:
double precision:: dsx(0:nxm1,0:ny),dsy(0:nxm1,ny)
double precision:: dpy(ny,0:nxm1)
integer:: iz

!-------------------------------------------------------------------
 !Loop over layers:
do iz=1,nz
    !Compute df/dx spectrally:
   call xderiv_fc(nx,ny,hrkx,fs(:,:,iz),dsx)
    !Convert to physical space as fx:
   call spctop_fc(nx,ny,dsx,fx(:,:,iz),xfactors,yfactors,xtrig,ytrig)

    !Compute df/dy spectrally:
   call yderiv_fc(nx,ny,rky(1:ny),fs(:,:,iz),dsy)
    !Convert to physical space:
   call spctop_fs(nx,ny,dsy,dpy,xfactors,yfactors,xtrig,ytrig)
    !Store in fy and insert zero boundary values at ymin & ymax:
   fy(1:nym1,:,iz)=dpy(1:nym1,:)
   fy( 0,:,iz)=zero
   fy(ny,:,iz)=zero
enddo

return
end subroutine gradient

!=======================================================================

end module spectral
