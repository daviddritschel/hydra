program collapse
! Initialises three vortices in a collapse configuration (if points).

use constants

implicit double precision(a-h,o-z)

!integer,parameter:: ngridf=nxf*nyf,nbytesf=4*(ngridf+1)
double precision:: qod0(nyu/2),qod1(nyu/2),qod2(nyu/2)
double precision:: qev0(0:nyu/2),qev1(0:nyu/2),qev2(0:nyu/2)
double precision:: qa(nyu,nxu),qq(ny,nx)
double precision:: kappa(3),xc(3),yc(3),rad(3),bm(3)
double precision:: radsqi(3)

!-------------------------------------------------------------------
! Read data generated by ~/math/pointv/sqg/src/collapse2.py:
open(10,file='strengths.asc',status='old')
do j=1,3
   read(10,*) kappa(j)
enddo
close(10)

open(10,file='coordinates.asc',status='old')
read(10,*)
do j=1,3
   read(10,*) xc(j),yc(j)
enddo
close(10)

!-------------------------------------------------------------------
! Create distributed vortices for use in contour advection:
write(*,*)
write(*,*) ' Each vortex has a buoyancy profile b(r)/N = b_m*(1 - r^2/R^2)^p.'
write(*,*) ' Power p? '
read(*,*) pow

write(*,*)
write(*,*) ' Choose one of the following flow initialisation methods:'
write(*,*) ' (1) all vortices have same |b_m| but different radii R, or'
write(*,*) ' (2) all vortices have same R but different b_m.'
write(*,*) ' Choice? '
read(*,*) iopt

s1sq=(xc(2)-xc(3))**2+(yc(2)-yc(3))**2
s2sq=(xc(3)-xc(1))**2+(yc(3)-yc(1))**2
s3sq=(xc(1)-xc(2))**2+(yc(1)-yc(2))**2
dmin=sqrt(min(s1sq,s2sq,s3sq))
dmax=sqrt(max(s1sq,s2sq,s3sq))

write(*,*)
write(*,'(a,f9.6)') ' The minimum inter-vortex distance is ',dmin
write(*,'(a,f9.6)') ' The maximum inter-vortex distance is ',dmax

if (iopt == 1) then
   write(*,*) ' Without loss of generality, we take |b_m| = 2*(p+1)*C.'
   write(*,*) ' Enter C > 1:'
   read(*,*) c0
   bm0=-two*(pow+one)*c0
   do j=1,3
      ss=sign(one,kappa(j))
      bm(j)=ss*bm0
      rad(j)=sqrt(ss*kappa(j)/c0)
   enddo
else
   write(*,*) ' Enter the radius R:'
   read(*,*) rad0
   fac=-two*(pow+one)/rad0**2
   do j=1,3
      rad(j)=rad0
      bm(j)=fac*kappa(j)
   enddo
endif
radsqi=one/rad**2
write(*,*) ' b_m = ',bm
write(*,*) ' R   = ',rad
write(*,*) ' 1/R^2 = ',radsqi
write(*,*) ' xc = ',xc
write(*,*) ' yc = ',yc

!-------------------------------------------------------------------
! Create data on the fine grid and coarsen for use in simulation:
glxf=ellx/dble(nxu)
glyf=elly/dble(nyu)
qa=zero
do j=1,3
   do ix=1,nxu
      x=xmin+glxf*dble(ix-1)
      do iy=1,nyu
         y=ymin+glyf*dble(iy-1)
         ssq=radsqi(j)*((x-xc(j))**2+(y-yc(j))**2)
         if (ssq < one) then
            qa(iy,ix)=bm(j)*(one-ssq)**pow
         endif
      enddo
   enddo
enddo
write(*,*) ' max(qa) = ',maxval(qa)
write(*,*) ' min(qa) = ',minval(qa)

!------------------------------------------------------------------------
 !Average the buoyancy field in qa to the coarser grid (ny,nx):
nxh=nxu
nyh=nyu
do while (nxh .gt. nx)
   nxuf=nxh
   nxh=nxh/2
   nyuf=nyh
   nyh=nyh/2
    !Perform nine-point averaging:
   do iy=1,nyh
      miy=2*iy
      qod2(iy)=qa(miy-1,nyuf)
      qev2(iy)=qa(miy,nyuf)
   enddo
   qev2(0)=qa(nyuf,nyuf)
   do ix=1,nxh
      mix=2*ix
      mixm1=mix-1
      do iy=1,nyh
         miy=2*iy
         qod1(iy)=qa(miy-1,mixm1)
         qod0(iy)=qa(miy-1,mix)
         qev1(iy)=qa(miy,mixm1)
         qev0(iy)=qa(miy,mix)
      enddo
      qev1(0)=qev1(nyh)
      qev0(0)=qev0(nyh)
      do iy=1,nyh
         qa(iy,ix)=0.0625d0*(qev0(iy)+qev0(iy-1)+qev2(iy)+qev2(iy-1)) &
                   +0.125d0*(qev1(iy)+qev1(iy-1)+qod0(iy)+qod2(iy)) &
                   +0.25d0*qod1(iy)
      enddo
      do iy=1,nyh
         qod2(iy)=qod0(iy)
         qev2(iy)=qev0(iy)
      enddo
      qev2(0)=qev0(0)
   enddo
enddo

 !Calculate and remove average qq:
qavg=zero
do ix=1,nx
   do iy=1,ny
      qavg=qavg+qa(iy,ix)
   enddo
enddo
qavg=qavg/dble(nx*ny)

 !Save average for plotting purposes:
open(44,file='average_qq.asc',status='replace')
write(44,*) qavg
close(44)

do ix=1,nx
   do iy=1,ny
      qq(iy,ix)=qa(iy,ix)-qavg
   enddo
enddo

open(11,file='qq_init.r8',form='unformatted', &
      access='direct',status='replace',recl=2*nbytes)
write(11,rec=1) zero,qq
close(11)

end program collapse
