#!/usr/bin/env python

# This script plots cross sections at x or y = 0 of b', p, u, v,
# xi, eta, zeta and Ri (the Richardson number) from data in the 
# 3d subdirectory (generated by balance.f90 in src/post).

#     @@@@   Run from the current job directory   @@@@

#========== Perform the generic imports =========
import sys,os,warnings
import numpy as np
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.artist import setp
import matplotlib.cm as cm
import matplotlib as mpl
from matplotlib import rcParams
from matplotlib import rc
rcParams.update({'figure.autolayout': True})
warnings.simplefilter("ignore",DeprecationWarning)

# Ensure latex fonts throughout:
rc('font', **{'family': 'Times New Roman'})
rc('text', usetex=True)

# set tick label size:
label_size = 20
mpl.rcParams['xtick.labelsize'] = label_size
mpl.rcParams['ytick.labelsize'] = label_size
# set x tick width and size:
mpl.rcParams['xtick.major.size'] = 5
mpl.rcParams['xtick.major.width'] = 2
mpl.rcParams['xtick.minor.size'] = 3
mpl.rcParams['xtick.minor.width'] = 1
# set y tick width and size:
mpl.rcParams['ytick.major.size'] = 5
mpl.rcParams['ytick.major.width'] = 2
mpl.rcParams['ytick.minor.size'] = 3
mpl.rcParams['ytick.minor.width'] = 1
# set axes width:
mpl.rcParams['axes.linewidth'] = 1

#====================== Function definitions =======================
def contint(fmin,fmax):
    #Determines a nice contour interval (giving 10-20 divisions with
    #interval 1, 2 or 5x10^m for some m) given the minimum & maximum
    #values of the field data (fmin & fmax).

    fmax=0.9999999*fmax
    fmin=0.9999999*fmin
    #The 0.99... factor avoids having a superfluous tick interval
    #in cases where fmax-fmin is 10^m or 2x10^m

    emag=1.0
    rmult=fmax-fmin
    while rmult < 10:
       emag=emag/10
       rmult=rmult*10

    while rmult >= 100:
       emag=emag*10
       rmult=rmult/10

    kmult=int(rmult/10)

    if kmult < 1:
       ci=emag
    elif kmult < 2:
       ci=2*emag
    elif kmult < 4:
       ci=4*emag
    elif kmult < 8:
       ci=10*emag
    else:
       ci=20*emag

    return ci

#https://stackoverflow.com/questions/18926031/how-to-extract-a-subset-of-a-colormap-as-a-new-colormap-in-matplotlib
def sub_cmap(cmap, vmin, vmax):
    return lambda v: cmap(vmin + (vmax - vmin) * v)

#======================================================================
# Work out grid resolution (ng & nz) by reading it from parameters.f90:
in_file=open('src/parameters.f90','r')
fread=in_file.readlines()
for line in fread:
   if ':: ng=' in line:
      pline=line

line=pline.split("=")[1]
ng=int(line.split(",")[0])
line=pline.split("=")[2]
nz=int(line.split(",")[0])+1
N=ng*ng*nz

# Also read f & N to adjust aspect ratio:
for line in fread:
   if ':: cof=' in line:
      pline=line

line=pline.split("=")[1]
txt=line.split(",")[0]
cof=float(txt.rstrip("d0"))
line=pline.split("=")[2]
txt=line.split(",")[0]
bvf=float(txt.rstrip("d0\n"))
epsi=bvf/cof

# To show more contour lines in main image:
mult=2

#==============================================================================
# Set up figure:
aspect=epsi*float(nz)/float(ng)
nrow=4
ncol=2
nf=nrow*ncol
fig, ax = plt.subplots(figsize=[15,float(nrow)*(12*aspect/float(ncol)+0.5)], nrows=nrow, ncols=ncol)
ax = ax.flatten()

# Fields to plot and filename prefixes:
field_acro=['$b^\\prime$','$\\phi$','$u$','$v$','$\\xi$','$\\eta$','$\\zeta$','Ri']
field_list=['ba','pp','ux','uy','ox','oy','oz','ri']

# Starting fraction of colourmap:
cmap_vmin=np.array([0.5,0.0,0.0,0.0,0.0,0.0,0.0,0.5])

# Define colourmap:
cmap = mpl.cm.get_cmap('seismic')

# Extent in x & z (xlen & zlen):
xhw=np.pi
xlen=2.0*xhw
zlen=epsi*xlen*float(nz-1)/float(ng)
extent=np.array([-xhw,xhw,-zlen,0.0])

#==============================================================================
# Loop over fields and plot:
for j in range(nf):
    # Read data into array for plotting:
    in_file=open('3d/'+field_list[j]+'.r4','r')
    raw_array=np.fromfile(in_file,dtype=np.float32)
    in_file.close()
    A=np.empty([nz,ng,ng])
    A=raw_array[1:N+1].reshape(nz,ng,ng)
    iy=int(ng/2+0.5)
    Z=np.empty([nz,ng+1])
    Z[:,0:ng]=A[:,0:ng,iy]
    Z[:,ng]=Z[:,0]

    #------------------------------------------------------------
    # Work out the overall min/max values:
    zmin=np.amin(Z)
    zmax=np.amax(Z)
    print(zmin,zmax)
    zmag=max(abs(zmin),abs(zmax))
    zmin=-zmag
    zmax= zmag

    #------------------------------------------------------------
    # Obtain contour levels for plotting the colorbars:
    dz=contint(zmin,zmax)
    jmin=-int(-zmin/dz)
    jmax= int( zmax/dz)
    clevels=np.linspace(dz*float(jmin),dz*float(jmax),jmax-jmin+1)
    dz=dz/mult
    jmin=-int(-zmin/dz)
    jmax= int( zmax/dz)
    clevelsf=np.linspace(dz*float(jmin),dz*float(jmax),jmax-jmin+1)

    #------------------------------------------------------------
    # Plot in the appropriate frame:
    ax1=ax[j]

    ax1.set_xlim([-xhw,xhw])
    ax1.set_ylim([-zlen,0.0])

    ax1.set_title(field_acro[j], fontsize=20)

    if ncol == 1:
        if j == nf-1:
            ax1.set_xlabel('$x$', fontsize=20)
        else:
            plt.setp(ax1.get_xticklabels(), visible=False)
            ax1.set_ylabel('$Nz/f$', fontsize=20)
    else:
        if j == nf-1 or j == nf-2:
            ax1.set_xlabel('$x$', fontsize=20)
        else:
            plt.setp(ax1.get_xticklabels(), visible=False)
        if j%2 == 0:
            ax1.set_ylabel('$Nz/f$', fontsize=20)

    # Plot the image in an array with an optional colourbar:
#    new_cmap = sub_cmap(cmap, cmap_vmin[j], 1.0)
    im1=ax1.imshow(Z,cmap='seismic',vmin=zmin,vmax=zmax,extent=extent,origin='lower',interpolation='bilinear')
    cs1=ax1.contour(Z, clevelsf, colors='k', extent=extent, linewidths=1)
    divider = make_axes_locatable(ax1)
    cax1 = divider.append_axes("right", size="4%", pad=0.1)
    cbar=fig.colorbar(im1, cax=cax1, ticks=clevels)
    cbar.ax.tick_params(labelsize=15)
    cbar.add_lines(cs1)

fig.subplots_adjust(wspace=0.8, hspace=0.0)

#=========================================================================
# Save image:
fig.savefig('cross.eps', format='eps', dpi=600)

print()
print(' To view the image, type')
print()
print(' gv cross.eps &')
print()
